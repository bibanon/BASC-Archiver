#!/usr/bin/env python
# -*- coding: utf-8 -*-
# BASC Imageboard Archiver GUI
from __future__ import print_function
from __future__ import absolute_import
import random
import time
import json
import sys
import os

import appdirs
import threading
from PySide import QtCore, QtGui

from basc_archiver.gui import Ui_MainWindow
from basc_archiver import Options, Archiver


class ThreadSecondsCounter(threading.Thread):
    """Counts the seconds down in the thread counter."""
    STATUS_DELAY = 3  # 3 seconds before setting new statuses

    def __init__(self, gui):
        threading.Thread.__init__(self)
        self.gui = gui
        self.daemon = True
        self.start()

    def run(self):
        while True:
            # gui shutdown
            if not self.gui.running:
                exit(0)

            current_ts = time.time()

            with self.gui.thread_list_lock:
                for i, lst in enumerate(self.gui.thread_list):
                    if lst['last_status'] + self.STATUS_DELAY < current_ts:
                        if lst.get('stopped', False):
                            # we set the status here because image / thumb dl messages may
                            #   override the 'stopped' message. Could make this more complex
                            #   but we should do that later, once we know it's needed
                            status = 'Stopped'
                            self.gui._set_status(i, status)
                        elif lst['next_dl'] is not None:
                            seconds = int(lst['next_dl'] - current_ts)
                            if seconds < 1:
                                status = 'Waiting'
                            else:
                                status = 'Waiting {} seconds'.format(seconds)
                            self.gui._set_status(i, status)

            time.sleep(1)


class GuiOptions(Options):
    def __init__(self, base_app_dir):
        # make sure data dir exists
        if not os.path.exists(base_app_dir):
            os.makedirs(base_app_dir)

        # open config file if it exists
        self._path = os.path.join(base_app_dir, 'config.json')
        config_dict = self.load()

        # create settings
        base_dir = config_dict.get('base_dir', os.path.join(os.path.expanduser('~'), 'thread-archive'))
        use_ssl = config_dict.get('use_ssl', False)
        silent = config_dict.get('silent', False)
        verbose = config_dict.get('verbose', False)
        self.gui_single_dl = config_dict.get('gui_single_dl', False)
        thread_check_delay = config_dict.get('thread_check_delay', 90)
        skip_thumbs = config_dict.get('skip_thumbs', False)
        thumbs_only = config_dict.get('thumbs_only', False)
        follow_child_threads = config_dict.get('follow_child_threads', False)
        follow_to_other_boards = config_dict.get('follow_to_other_boards', False)

        # create actual options object
        super(GuiOptions, self).__init__(base_dir, use_ssl=use_ssl,
                                         silent=silent, verbose=verbose,
                                         thread_check_delay=thread_check_delay,
                                         skip_thumbs=skip_thumbs, thumbs_only=thumbs_only,
                                         follow_child_threads=follow_child_threads,
                                         follow_to_other_boards=follow_to_other_boards)

        self.save()

    def load(self):
        try:
            with open(self._path, 'r') as config_file:
                config_string = config_file.read()
                config_dict = json.loads(config_string)
        except FileNotFoundError:
            config_dict = {}
        return config_dict

    def save(self):
        config_dict = {
            'base_dir': self.base_dir,
            'use_ssl': self.use_ssl,
            'silent': self.silent,
            'verbose': self.verbose,
            'gui_single_dl': self.gui_single_dl,
            'thread_check_delay': self.thread_check_delay,
            'skip_thumbs': self.skip_thumbs,
            'thumbs_only': self.thumbs_only,
            'follow_child_threads': self.follow_child_threads,
            'follow_to_other_boards': self.follow_to_other_boards,
        }

        with open(self._path, 'w') as config_file:
            config_string = json.dumps(config_dict, sort_keys=True, indent=4, separators=(',', ': '))
            config_file.write(config_string)
            config_file.write('\n')


class MainWindow(QtGui.QMainWindow, Ui_MainWindow):
    def __init__(self, parent=None, archiver=None):
        super(MainWindow, self).__init__(parent)
        self.setupUi(self)

        self.running = True

        self.thread_list_lock = threading.Lock()
        self.thread_list = []

        # make sure we have an archiver to attach to
        if archiver is None:
            raise Exception('The `archiver` attribute must be set when instantiating MainWindow')
        self.archiver = archiver

        # connect up status
        self.archiver.register_callback('new_thread', self.status_new_thread)
        self.archiver.register_callback('thread_dl', self.status_dl)
        self.archiver.register_callback('image_dl', self.status_dl)
        self.archiver.register_callback('thumb_dl', self.status_dl)
        self.archiver.register_callback('404', self.status_404)
        self.archiver.register_callback('thread_start_download', self.status_start_dl)

        # set options
        self.saveWarc.setEnabled(False)  # until we support WARC files

        if not self.archiver.options.skip_thumbs:
            self.downloadThumbs.setCheckState(QtCore.Qt.Checked)
        if not self.archiver.options.thumbs_only:
            self.downloadImages.setCheckState(QtCore.Qt.Checked)

        if self.archiver.options.follow_child_threads:
            self.followChildren.setCheckState(QtCore.Qt.Checked)
        if self.archiver.options.follow_to_other_boards:
            self.followExternalBoards.setCheckState(QtCore.Qt.Checked)

        if self.archiver.options.gui_single_dl:
            self.singleDownload.setCheckState(QtCore.Qt.Checked)

        self.downloadThumbs.clicked.connect(self.skip_thumbs_button)
        self.downloadImages.clicked.connect(self.thumbs_only_button)
        self.followChildren.clicked.connect(self.follow_child_threads_button)
        self.followExternalBoards.clicked.connect(self.follow_to_other_boards_button)
        self.singleDownload.clicked.connect(self.single_dl_button)
        # TODO: set rest of option buttons according to options
        # TODO: make sure that clicking option buttons updates button object in-memory and on-disk
        # TODO: make slug/status columns double the width of others
        # TODO: make sure adding URL is added to the options, also keep track of whether thread
        #   has 404'd in options, so we don't need to recheck /those/ ones on startup
        # TODO: change minutes to seconds in 'Check every x minutes' display, and actually have it
        #   set the proper download delay with the library (will require changes to threaded arch)
        # TODO: in thread_dl status, show how many new replies there were
        # TODO: with thread_dl status, force it to display for a second or two (before the image/
        #   thumbnail stuff starts flooding in?) Maybe a var to force no status changes until a
        #   timestamp has passed?

        # setting up thread list
        self.threadList.setEditTriggers(QtGui.QAbstractItemView.EditTriggers())  # disable cell editing
        self.threadList.setColumnCount(5)
        self.threadList.setHorizontalHeaderLabels(['Site', 'Board', 'Thead ID', 'Slug', 'Status'])
        self.threadList.verticalHeader().setVisible(False)  # hide row numbers
        # self.threadList.horizontalHeader().setResizeMode(QtGui.QHeaderView.Stretch)
        self.threadList.horizontalHeader().setResizeMode(QtGui.QHeaderView.Interactive)  # todo: make this stretch

        self.threadList.verticalHeader().setContextMenuPolicy(QtCore.Qt.CustomContextMenu)

        # connecting slots
        self.actionAbout.triggered.connect(self.show_about)
        self.actionPreferences.triggered.connect(self.show_preferences)
        self.actionExit.triggered.connect(QtGui.qApp.quit)

        self.addThread.clicked.connect(self.add_thread)
        self.addFromClipboard.clicked.connect(self.add_from_clipboard)

        # startup thread seconds counter
        ThreadSecondsCounter(self)

    def show_about(self):
        QtGui.QMessageBox.about(self, 'BASC-Archiver', '<center><h1>BASC-Archiver</h1></center> The <b>BASC Archiver</b> is a Python library/utility written by Bibliotheca Anonoma to archive imageboard threads. Developers are free to use the library for their own applications, as it is licensed under the LGPLv3.')

    def show_preferences(self):
        QtGui.QMessageBox.about(self, 'BASC-Archiver', "<center><h1>Oh no!</h1></center> Preferences menu to go here, but it's not done yet! Sorry!")

    # option buttons
    def skip_thumbs_button(self):
        self.archiver.options.skip_thumbs = not self.downloadThumbs.isChecked()
        self.archiver.options.save()

    def thumbs_only_button(self):
        self.archiver.options.thumbs_only = not self.downloadImages.isChecked()
        self.archiver.options.save()

    def follow_child_threads_button(self):
        self.archiver.options.follow_child_threads = self.followChildren.isChecked()
        self.archiver.options.save()

    def follow_to_other_boards_button(self):
        self.archiver.options.follow_to_other_boards = self.followExternalBoards.isChecked()
        self.archiver.options.save()

    def single_dl_button(self):
        self.archiver.options.gui_single_dl = self.singleDownload.isChecked()
        self.archiver.options.save()

    def _add_thread_list_entry(self, site, board, thread_id, slug, status):
        self.threadList.insertRow(0)

        twi = QtGui.QTableWidgetItem(site)
        self.threadList.setItem(0, 0, twi)

        twi = QtGui.QTableWidgetItem(board)
        self.threadList.setItem(0, 1, twi)

        twi = QtGui.QTableWidgetItem(str(thread_id))
        self.threadList.setItem(0, 2, twi)

        twi = QtGui.QTableWidgetItem(slug)
        self.threadList.setItem(0, 3, twi)

        twi = QtGui.QTableWidgetItem(status)
        self.threadList.setItem(0, 4, twi)

    def _set_status(self, table_y, status):
        """Sets status of the given thread object in our table.

        This function is NOT THREAD SAFE, and the calling function must have obtained
        the self.thread_list_lock lock BEFORE CALLING THIS FUNCTION. Or else,
        everything will probably die.
        """
        self.threadList.setItem(table_y, 4, QtGui.QTableWidgetItem(status))

    def add_thread(self):
        text = self.threadUrl.text()
        only_download_once = self.singleDownload.isChecked()
        dl_delay = self.checkSeconds.value()

        worked = self.archiver.add_thread(text, only_download_once=only_download_once, download_delay_in_seconds=dl_delay)

        if text:
            print('adding thread:', text)
            if only_download_once:
                print('  only downloading thread once')
            else:
                print('  checking thread every', dl_delay, 'seconds')
            if worked:
                self.threadUrl.clear()

    def status_new_thread(self, cb_name, info):
        """basc_archiver added a new thread."""
        site = info['site']
        board = info['board']
        thread_id = info['thread_id']
        # slug = info['slug']
        slug = 'test-slug'
        status = 'Downloading'

        self._add_thread_list_entry(site, board, thread_id, slug, status)
        with self.thread_list_lock:
            self.thread_list.insert(0, {
                'site': site,
                'board': board,
                'thread_id': thread_id,
                'last_status': time.time(),
                'next_dl': None,
            })

    def status_dl(self, cb_name, info):
        """basc_archiver dl'd something."""
        site = info['site']
        board = info['board']
        thread_id = info['thread_id']

        with self.thread_list_lock:
            for i, lst in enumerate(self.thread_list):
                if site == lst['site'] and board == lst['board'] and thread_id == lst['thread_id']:
                    status = None
                    if cb_name == 'thread_dl':
                        status = 'Thread HTML Downloaded'
                        self.thread_list[i]['next_dl'] = info['next_dl']
                        self.thread_list[i]['stopped'] = info['stopped']
                    elif cb_name == 'image_dl':
                        status = 'Image Downloaded ({}/{})'.format(info['images_downloaded'], info['total_files'])
                    elif cb_name == 'thumb_dl':
                        status = 'Thumbnail Downloaded ({}/{})'.format(info['thumbs_downloaded'], info['total_files'])
                    if status is not None:
                        self.thread_list[i]['last_status'] = time.time()
                        self._set_status(i, status)

    def status_start_dl(self, cb_name, info):
        """basc_archiver started to dl a thread."""
        site = info['site']
        board = info['board']
        thread_id = info['thread_id']

        with self.thread_list_lock:
            for i, lst in enumerate(self.thread_list):
                if site == lst['site'] and board == lst['board'] and thread_id == lst['thread_id']:
                    status = 'Downloading'
                    self.thread_list[i]['last_status'] = time.time()
                    self._set_status(i, status)

    def status_404(self, cb_name, info):
        """basc_archiver dl'd something."""
        site = info['site']
        board = info['board']
        thread_id = info['thread_id']

        with self.thread_list_lock:
            for i, lst in enumerate(self.thread_list):
                if site == lst['site'] and board == lst['board'] and thread_id == lst['thread_id']:
                    status = 'Thread No Longer Exists'
                    self.thread_list[i]['last_status'] = time.time()
                    self._set_status(i, status)

    def add_from_clipboard(self):
        print('adding thread from clipboard')

if __name__ == '__main__':
    random.seed()

    base_options_dir = appdirs.user_data_dir('thread-archiver', 'basc')
    options = GuiOptions(base_options_dir)
    archiver = Archiver(options)

    app = QtGui.QApplication(sys.argv)
    window = MainWindow(archiver=archiver)
    window.setWindowTitle('BASC-Archiver')
    window.show()
    sys.exit(app.exec_())
